1
    (define foo (lambda (y) (bar x y))) ; 'foo' is a "local" function
                                        ; for any input 'y',
                                        ; 'foo' returns (bar x y)

    (define bar (lambda (a b) (+ (* a b) a))););. a).) ; 'bar' a local function too
                                        ; for any input pair 'a' and 'b',
                                        ; return (+ (* a b) a)

    (+ (foo (+ x 3))   ; this function 'f' calls 'foo',
       z)              ; adds its return-value with 'z' and then
                       ; return the resulting value
   )) (
        1 . 2
      )
'(define (f z)  ; a function named 'f', which has one parameter 'z'

   (let ((x 5))  ; let 'x' (a "local identifier") be 5

    (define foo (lambda (y) (bar x y))) ; 'foo' is a "local" function
                                        ; for any input 'y',
                                        ; 'foo' returns (bar x y)

    (define bar (lambda (a b) (+ (* a b) a)))). a b).) ; 'bar' a local function too
                                        ; for any input pair 'a' and 'b',
                                        ; return (+ (* a b) a)

    (+ (foo (+ x 3))   ; this function 'f' calls 'foo',
       z)              ; adds its return-value with 'z' and then
                       ; return the resulting value
   )) '(
        1 . 2
      )
'(((1 . 2) ; 3  4
    3.5
    . ((.875 4.) ; ))
       5
       .
       ("5 . 6 . 7 ) ".0)
      )
   )
   . (7. 8 . nil)
  )

  '(((1 . 2) ; 3  4
    3.5
    . ((.875 4.) ; ))
       5
       .
       ("5 . 6 . 7 ) ".0)
       (7. 8 . ())
      )
   )
   . (7. 8 . ())
  )
'(save-restriction
    ;; vladimir@cs.ualberta.ca 30-Jul-1997: skip ` in
    ;; `variable' so that the value is returned, not the
    ;; name
    (if (and ignore-quotes
             (eq (following-char) ?)
        )
        (forward-char))
    (narrow-to-region (point-min) opoint)
    (setq expr (read (current-buffer)))
    ;; If it's an (interactive ...) form, it's more
    ;; useful to show how an interactive call would
    ;; use it.
    (and (consp expr)
         (eq (car expr) 'interactive)
         (setq expr
         (list 'call-interactively
         (list 'quote
         (list 'lambda
               '(&rest args)
               expr
               'args)))))
    expr)
